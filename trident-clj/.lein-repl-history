(clj-time/now)
(require '(clj-time.core :as clj-time))
(require '[clj-time.core :as clj-time])
(clj-time/now)
(def n (clj-time/now))
n
nowfmt (clj-time.format/unparse (clj-time.format/formatters :date-time) now)
(clj-time.format/unparse (clj-time.format/formatters :date-time) n)
(require '[clj-time.format])
(clj-time.format/unparse (clj-time.format/formatters :date-time) n)
(show-formatter)
(show-formatters)
(clj-time/format/show-formatters)
(clj-time.format/show-formatters)
(clj-time.format/unparse (clj-time.format/formatters :date-time) n)
(str "er-" 3)
(def mp (atom {}))
)
mp
@mp
(merge-with inc {:a 1} {:b 2})
(merge-with inc {:a 1} {:a 2})
(merge-with + {:a 1} {:a 2})
(merge-with + {:a 1 :c 4} {:a 2 :b 3})
mp]
mp
@mp
(swap! mp merge-with + {:a 1})
(merge-with + {} {:a 1})
(apply merge-with {} + {:a 1})
(apply merge-with + {} {:a 1})
(apply merge-with + (map #(apply hash-map %) {:a 1 :b 2 :c 1 :d 2 :e 5}))
 (map #(apply hash-map %) {:a 1 :b 2 :c 1 :d 2 :e 5})
(apply merge-with + {} {:a 1})
(apply merge-with + [{} {:a 1}])
(apply merge-with + (vector {} {:a 1})
)
(swap! mp merge-with + (vector {:a 1}))
(merge-with + {} {:a 1})
(swap! mp (fn [s] (merge-with + {:a 1}))
)
@mp
(swap! mp (fn [s] (merge-with + {:a 2})))
@mp 
(swap! mp (fn [s] (merge-with + s {:a 2})))
(swap! mp (fn [s] (merge-with + s {:b 2})))
(@mp :a)
(@mp :c)
((fnil inc 0) (@mp :c))
((fnil inc 0) 2)
(inc nil)
(keyword "a")
(to-array :a "b")
(to-array [:a "b"])
(rand)
(rand-int)
(rand-int 10)
(repeatedly 100 rand)
(doc repeatedly)
(doc repeat)
(take 4 (repeat inc 1))
(take 4 (repeat 1))
(hash-map :a 1)
(require [clojure.java.io :only reader])
(with-open [rdr (clojure.java.io/reader "/Users/e51141/tmp/x")]
(printf "%s\n" (clojure.string/join "\n" (line-seq rdr))))
(require [clojure.java.io :only reader])
(require '(clojure.java.io :only reader)
)
(require '(clojure.java.io :only reader))
(require [clojure.java.io :only reader])
(require '[clojure.java.io :only reader])
(with-open [rdr (reader "/Users/e51141/tmp/x")]) (prn rdr))
(require '[clojure.java.io :only reader :refer reader])
(require '[clojure.java.io :only reader :refer readers])
(require '[clojure.java.io :only reader])
(require '[clojure.java.io :only [reader] :refer [reader]])
(with-open [rdr (reader "/tmp/x")] (prn rdr))
(with-open [rdr (reader "/Users/e51141/tmp/x")] (prn rdr))
(with-open [rdr (reader "/Users/e51141/tmp/x")]
(printf "%s\n" (clojure.string/join "\n" (line-seq rdr))))
(with-open [rdr (reader "/Users/e51141/tmp/x")]
(for [l (line-seq rdr)]
  (prn l)))
(with-open [rdr (reader "/Users/e51141/tmp/x")]
(for [l (line-seq rdr)] (prn l)))
(with-open [rdr (reader "/Users/e51141/tmp/x")]
(doseq [l (line-seq rdr)] (prn l)))
(with-open [rdr (reader "/Users/e51141/tmp/x")]
(doseq [l (line-seq rdr)] (prn "2") (prn l)))
(second [1 2])
(require '[clojure.java.io :only [reader] :refer [reader]])
(reader)
(def l "9/28/2005 13:00,16")
l.split(",")
(split l ",")
(split)
(clojure.string/split l #",")
(map (fn [nm] (ns-resolve 'clj-time.core (symbol nm))) ["year" "month" "day"]
)
(def fns (map (fn [nm] (ns-resolve 'clj-time.core (symbol nm))) ["year" "month" "day"])
)
fns
(map (fn [f] (format "%02d" (f now))) fns)
(def now (clj-time.local/local-now))
(. System exit 0)
